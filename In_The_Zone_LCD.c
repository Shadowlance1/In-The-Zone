#pragma config(Sensor, in2,    BATTERY_2_PORT, sensorAnalog)
#pragma config(Sensor, in3,    LeftClawPotent, sensorPotentiometer)
#pragma config(Sensor, in5,    ArmPotent,      sensorPotentiometer)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, in7,    RightClawPotent, sensorPotentiometer)
#pragma config(Sensor, in8,    LCDPotent,      sensorPotentiometer)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LCD setup
*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
string batteryLevel2 = (int) ((float)SensorValue[BATTERY_2_PORT] / 275);
void reset() {
	clearLCDLine(0);
	clearLCDLine(1);
	vexLcdClearLine(0);
	vexLcdClearLine(1);

	displayLCDCenteredString(0, "Reseting");
	writeDebugStreamLine("Reset");
	//variables
	Menu1 = 2;
	Menu2 = 0;
	AutonChoice = -1;

	wait1Msec(2000);
}

void startup() {

}

void autonomousLCD() { //LCD for selecting autonomous

	displayLCDCenteredString(0, "Autonomous");

	resetLimitMenu2(0,2);
	resetLimitLCDEncoder(0, 360);
	menu2Control();

	switch(Menu2) {
	case 0:
		vexLcdSet(0, "     Nothing    ");
		vexLcdSet(1, "");
		autonSelection(0);
		break;

	case 1:
		vexLcdSet(0, "    BlueRight   ");
		vexLcdSet(1, "");
		autonSelection(1);
		break;

	case 2:
		vexLcdSet(0, "    BlueLeft    ");
		vexLcdSet(1, "");
		autonSelection(2);
		break;


	}
}

void sensorValueLCD() {
	displayLCDCenteredString(0, "Sensor");

	menu2Control();
	resetLimitMenu2(0,5);
	resetLimitLCDEncoder(0, 360);

	switch(Menu2) {
	case 0:
		vexLcdSet(0, "      Gyro      ");
		stringFormat(string4, "       %d       ", SensorValue[Gyro]);
		vexLcdSet(1, string4);
		break;
	case 1:
		vexLcdSet(0, "   Arm Potent   ");
		stringFormat(string4, "       %d       ", SensorValue[ArmPotent]);
		vexLcdSet(1, string4);
		break;
	case 2:
		vexLcdSet(0, "RightClawPotent ");
	//	stringFormat(string4, "       %d       ", SensorValue[RightClawPotent]);
		vexLcdSet(1, string4);
		break;
	case 3:
		vexLcdSet(0, " LeftClawPotent ");
		vexLcdSet(1, string4);
		break;
	case 4:
		vexLcdSet(0, "leftBaseEncoder ");
		stringFormat(string4, "       %d       ", SensorValue[leftBaseEncoder]);
		vexLcdSet(1, string4);
		break;
	case 5:
		vexLcdSet(0, "rightBaseEncoder");
		stringFormat(string4, "       %d       ", SensorValue[rightBaseEncoder]);
		vexLcdSet(1, string4);
		break;

	default:
		vexLcdSet(0, "Out of Range");
		break;
	}
}

void BatteryLCD() {

	displayLCDCenteredString(0, "Battery");

	menu2Control();
	resetLimitMenu2(0,2);
	resetLimitLCDEncoder(0, 360);

	switch(Menu2) {
	case 0:
		stringFormat(string2, "%1.2f%c", nImmediateBatteryLevel/1000.0);
		vexLcdSet(1, string2);
		vexLcdSet(0, "  Main Battery  ");
		break;
	case 1:
		vexLcdSet(0, "   Secondary    ");
		break;
	case 2:
		vexLcdSet(0, " Backup Battery ");
		stringFormat(string1, "%1.2f%c", BackupBatteryLevel);
		vexLcdSet(1, string1);
		break;
	default:
		vexLcdSet(0, "Out of Range");
		break;
	}
}

void driverLCD() {
	displayLCDCenteredString(0, "Driver");

	menu2Control();
	resetLimitMenu2(0,1);
	resetLimitLCDEncoder(0, 360);

	switch(Menu2) {
	case 0:
 		if(isPartner) {
			vexLcdSet(0, "     Single     ");
		}
		else {
			vexLcdSet(0, "     Single*    ");
		}

		if(nLCDButtons2 == CButton) {
			isPartner = false;
			waitForRelease2();
		}
		break;
	case 1:
		if(isPartner) {
			vexLcdSet(0, "    Partner*    ");
		}
		else {
			vexLcdSet(0, "     Partner    ");
		}
		if(nLCDButtons2 == CButton) {
			isPartner = true;
			waitForRelease2();
		}
		break;
	default:
		vexLcdSet(0, "Out of Range");
		break;
	}
}

void pidLCD() {
	displayLCDCenteredString(0, "PID");

	menu2Control();
	resetLimitMenu2(0,4);
	resetLimitLCDEncoder(0, 360);
	//vexLcdSet(1, string1);
	//stringFormat(string3, "%d", motor[leftDrive]);
	switch(Menu2) {
		case 0:
			vexLcdSet(0, "    BasePID     ");
			putPIDLCD(basePID);
			break;
		case 1:
			vexLcdSet(0, "     GyroPID    ");
			putPIDLCD(gyroPID);
			break;
		case 2:
			vexLcdSet(0, "     ArmPID     ");
			putPIDLCD(armPID);
			break;
		case 3:
			vexLcdSet(0, "   LeftClawPID  ");
			putPIDLCD(leftClawPID);
			break;
		case 4:
			vexLcdSet(0, "  RightClawPID  ");
			putPIDLCD(rightClawPID);
			break;
		default:
			displayLCDCenteredString(1, "Error");
			break;
		}
}

task LCD() {

	while (1 == 1) {

			if (nLCDButtons == LRButton) {
				reset();
			}
			if (nLCDButtons == LCButton) {

				stopTask(LCD);
			}

			resetLimitMenu1(0, 5);
			menu1Control();
			switch (Menu1) {
			case 0:
				displayLCDCenteredString(0, "Auto");
				autonomousLCD();
				break;
			case 1:
				displayLCDCenteredString(0, "Driver");
				driverLCD();
				break;
			case 2:
				displayLCDCenteredString(0, "Motor");

				break;
			case 3:
				displayLCDCenteredString(0, "PID");
				pidLCD();
				break;
			case 4:
				displayLCDCenteredString(0, "Sensor");
				sensorValueLCD();
				break;
			case 5:
				displayLCDCenteredString(0, "Battery");
				BatteryLCD();
				break;
			}
			wait1Msec(50);
	}
}
